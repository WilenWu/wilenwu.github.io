<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ 快速入门 | 雷小小</title><meta name="author" content="Tiny Lei"><meta name="copyright" content="Tiny Lei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C 语言是一种通用的、过程式的编程语言，广泛用于系统软件和应用程序开发。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。 https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F; https:&#x2F;&#x2F;www.studycpp.cn  基础知识  程序结构 以下代码是最简单的 C++程序之一，它将帮助我们理解 C++程序的基本语法结构。 &#x2F;&#x2F; Header file for in">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 快速入门">
<meta property="og:url" content="https://www.tinylei.tech/posts/3f4b6fbd/index.html">
<meta property="og:site_name" content="雷小小">
<meta property="og:description" content="C 语言是一种通用的、过程式的编程语言，广泛用于系统软件和应用程序开发。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。 https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F; https:&#x2F;&#x2F;www.studycpp.cn  基础知识  程序结构 以下代码是最简单的 C++程序之一，它将帮助我们理解 C++程序的基本语法结构。 &#x2F;&#x2F; Header file for in">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.tinylei.tech/img/cpp-introduction.png">
<meta property="article:published_time" content="2025-03-03T14:16:01.000Z">
<meta property="article:modified_time" content="2025-03-19T14:56:58.588Z">
<meta property="article:author" content="Tiny Lei">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.tinylei.tech/img/cpp-introduction.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.tinylei.tech/posts/3f4b6fbd/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="code-7rymn5Bitx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?654e7415ab55bed7c9c2bc6d665f03c5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 快速入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-19 22:56:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2849223_xh1ftc8qym.css"><link rel="stylesheet" href="/css/link-card.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="雷小小" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">110</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/user-guide/"><i class="fa-fw fa fa-compass"></i><span> 用户指南</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-book"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/ebook/"><i class="fa-fw fa fa-book-reader"></i><span> 电子书</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-star"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-solid fa-circle-chevron-down"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/analytics/"><i class="fa-fw fa fa-line-chart"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/log/"><i class="fa-fw fa fa-history"></i><span> 更新日志</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cpp-top-img.svg')"><nav id="nav"><span id="blog-info"><a href="/" title="雷小小"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png"/><span class="site-name">雷小小</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/user-guide/"><i class="fa-fw fa fa-compass"></i><span> 用户指南</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-book"></i><span> 文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-images"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/ebook/"><i class="fa-fw fa fa-book-reader"></i><span> 电子书</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-star"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-solid fa-circle-chevron-down"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/analytics/"><i class="fa-fw fa fa-line-chart"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/log/"><i class="fa-fw fa fa-history"></i><span> 更新日志</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ 快速入门<a class="post-edit-link" href="https://gitee.com/WilenWu/myblog/edit/master/source/_posts/C++/cpp-programming-language.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-03T14:16:01.000Z" title="发表于 2025-03-03 22:16:01">2025-03-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-19T14:56:58.588Z" title="更新于 2025-03-19 22:56:58">2025-03-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c/basics/">Basics</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ 快速入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>C 语言是一种通用的、过程式的编程语言，广泛用于系统软件和应用程序开发。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.cppreference.com/w/">https://en.cppreference.com/w/</a><br />
<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.studycpp.cn">https://www.studycpp.cn</a></p>
<h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1>
<h2 id="程序结构"><a class="markdownIt-Anchor" href="#程序结构"></a> 程序结构</h2>
<p>以下代码是最简单的 C++程序之一，它将帮助我们理解 C++程序的基本语法结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Header file for input output functions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main function: where the execution of C++ program begins</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This statement prints &quot;Hello World&quot;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>C++ 程序按照代码的书写顺序执行，其中<code>main()</code>函数是每个程序的入口点，且只有一个<code>main</code>函数。</li>
<li>语句块是一组使用大括号<code>&#123;&#125;</code> 括起来的按逻辑连接的语句。</li>
<li>每个语句必须以分号结束。</li>
<li>上例中 <code>#include&lt;iostream&gt;</code> 是一个预处理器指令，告诉编译器引入 C++标准输入/输出库 <code>iostream</code> 。</li>
<li><code>using namespace std</code> 将 std 命名空间的实体导入到程序中，它基本上是定义所有内置函数的空间。</li>
</ul>
<h2 id="编译和运行"><a class="markdownIt-Anchor" href="#编译和运行"></a> 编译和运行</h2>
<img title="" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/Compilation-Process-in-C.png" alt="compilation process in c" width="278" data-align="center">
<p>常用的编译器</p>
<ul>
<li>GCC 全称 GNU Compiler Collection，是由 GUN 项目开发的编译器套件。包含了 C、C++、Objective-C、Fortran、Ada 和 Go 等多种高级编程语言的编译器。</li>
<li>Clang 用于编译 C、C++、Objective-C 和 Objective-C++的编译器前段。采用 LLVM 为后端，一般 MacOS 下使用较多。</li>
<li>MSVC Microsoft 开发的 C 和 C++编译器，Windows 系统使用较多。</li>
</ul>
<p>大多数的 C++ 编译器并不在乎源文件的扩展名，一般默认使用 <strong>.cpp</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ helloworld.cpp -o hello</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2>
<p>C++有两种注释类型：单行注释 <code>//</code> 和多行注释 <code>/*...*/</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This is a single line comment</span></span><br><span class="line">    <span class="comment">/* This is a multi-line comment</span></span><br><span class="line"><span class="comment">     which can span multiple lines */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hi&quot;</span>; <span class="comment">// After line comment here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据类型与变量"><a class="markdownIt-Anchor" href="#数据类型与变量"></a> 数据类型与变量</h1>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<p>C++ 是一门静态类型语言。这意味着任何变量都有一个相关联的类型，并且该类型在编译时是可知的。</p>
<ul>
<li><strong>基本数据类型</strong>：<code>int</code>，<code>float</code>，<code>double</code>, <code>char</code>, <code>bool</code>, <code>void</code></li>
<li><strong>派生数据类型</strong>：数组(array)、指针(pointer)、引用(reference)、函数(function)、结构体(<code>struct</code>)、共用体(<code>union</code>)、枚举(<code>enum</code>)、类(<code>class</code>)</li>
<li><strong>数据类型修饰符</strong>：<code>short</code>, <code>long</code>, <code>signed</code>, <code>unsigned</code></li>
</ul>
<p>不同的数据类型也有不同的范围，这些范围可能因编译器而异。数据类型修饰符可作为前缀用于修改已有数据类型可以存储的数据大小或范围。以下是<strong>32 位 GCC 编译器</strong>上的范围列表以及内存要求和格式指定符。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Data Type</th>
<th style="text-align:center">Memory (bytes)</th>
<th style="text-align:center">Range</th>
<th style="text-align:center">Format Specifier</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>short int</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">-2<sup>15</sup> to 2<sup>15</sup>-1</td>
<td style="text-align:center"><code>%hd</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned short int</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">0 to 2<sup>16</sup>-1</td>
<td style="text-align:center"><code>%hu</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned int</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">0 to 2<sup>32</sup>-1</td>
<td style="text-align:center"><code>%u</code></td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">-2<sup>31</sup> to 2<sup>31</sup>-1</td>
<td style="text-align:center"><code>%d</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long int</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">-2<sup>31</sup> to 2<sup>31</sup>-1</td>
<td style="text-align:center"><code>%ld</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long int</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">0 to 2<sup>32</sup>-1</td>
<td style="text-align:center"><code>%lu</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long long int</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">-(2<sup>63</sup>) to 2<sup>63</sup>-1</td>
<td style="text-align:center"><code>%lld</code></td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long long int</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">0 to 2<sup>64</sup></td>
<td style="text-align:center"><code>%llu</code></td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">1.2E-38 to 3.4E+38</td>
<td style="text-align:center"><code>%f</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">1.7E-308 to 1.7E+308</td>
<td style="text-align:center"><code>%lf</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long double</code></td>
<td style="text-align:center">16</td>
<td style="text-align:center">3.4E-4932 to 1.1E+4932</td>
<td style="text-align:center"><code>%Lf</code></td>
</tr>
<tr>
<td style="text-align:center"><code>signed char</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128 to 127</td>
<td style="text-align:center"><code>%c</code></td>
</tr>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0 to 255</td>
<td style="text-align:center"><code>%c</code></td>
</tr>
</tbody>
</table>
<h2 id="定义变量"><a class="markdownIt-Anchor" href="#定义变量"></a> 定义变量</h2>
<p>当变量被定义时，它就会分配内存。分配的内存量取决于变量打算存储的数据类型。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/variable-memory-management-in-cpp.png" style="zoom:80%;" />
<p>变量本质是一块内存区域的别名，用来存储程序运行时需要的数据。变量在使用前必须声明，声明时指定数据类型，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age; <span class="comment">// Defining a variable</span></span><br><span class="line">age = <span class="number">25</span>; <span class="comment">// Initialize the variable</span></span><br></pre></td></tr></table></figure>
<p>也可同时声明和赋值变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Defining and initializing a variable</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">char</span> gender = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">2.5</span>;</span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">bool</span> isTrue = <span class="literal">true</span>; <span class="comment">// or false</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>char</code>类型使用单引号，用于存储单个字符。</p>
<p>C/C++ 允许一次创建多个变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;A&#x27;</span>, b;</span><br></pre></td></tr></table></figure>
<p>C++11 新增 <code>auto</code> 关键字，用于自动推断数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<h2 id="常量和宏"><a class="markdownIt-Anchor" href="#常量和宏"></a> 常量和宏</h2>
<p>使用<code>const</code>关键字声明常量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>也可以使用宏定义<code>#define</code>来表示常量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure>
<p>为了和变量区分开来，常量名通常<strong>全部大写</strong>。</p>
<h2 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h2>
<p>为防止命名冲突，C++引入了命名空间。以关键字 <code>namespace</code> 开头，后跟命名空间名称。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// first name space</span></span><br><span class="line"><span class="keyword">namespace</span> first</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;Inside first space&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// second name space</span></span><br><span class="line"><span class="keyword">namespace</span> second</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;Inside second space&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，大括号后没有分号。</p>
</blockquote>
<p>为了调用带有命名空间的函数或变量，需要用域解析操作符 <code>::</code> 来指明要使用的命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Calls function from first name space.</span></span><br><span class="line">      first :: <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">// Calls function from second name space.</span></span><br><span class="line">      second :: <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以采用 <code>using</code> 关键字引入整个命名空间，这样在使用命名空间时就可以不用加上前缀，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std;</span><br></pre></td></tr></table></figure>
<p><code>using</code> 指令也可以用来指定命名空间中的特定项目：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br></pre></td></tr></table></figure>
<p>随后的代码中，在使用 <code>cout</code> 时就可以不用加上命名空间名称作为前缀。</p>
<p><strong>不连续的命名空间</strong>：可以创建两个具有相同名称的命名空间块。第二个命名空间块实际上只不过是第一个命名空间的延续。因此，我们可以将一个命名空间的各个组成部分分散在多个文件中，例如 <code>std</code> 命名空间，C++标准库中的函数和类通常都位于 <code>std</code>命名空间中。</p>
<h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h1>
<p>在 C++中，运算符根据其执行的操作类型分为 6 种类型。</p>
<h2 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符"></a> 算术运算符</h2>
<p>算术运算符用于执行算术或数学运算。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">Plus</td>
<td style="text-align:center"><code>a + b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>–</code></td>
<td style="text-align:center">Minus</td>
<td style="text-align:center"><code>a – b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">Multiply</td>
<td style="text-align:center"><code>a * b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">Divide</td>
<td style="text-align:center"><code>a / b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center">Modulus</td>
<td style="text-align:center"><code>a % b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>++</code></td>
<td style="text-align:center">Increment</td>
<td style="text-align:center"><code>a++</code></td>
</tr>
<tr>
<td style="text-align:center"><code>--</code></td>
<td style="text-align:center">Decrement</td>
<td style="text-align:center"><code>a--</code></td>
</tr>
</tbody>
</table>
<p><code>a++</code> 与 <code>++a</code> 都是增量运算符，但是，两者都略有不同：<code>a++</code> 在使用 <code>a</code> 之后才自增它的值，而 <code>++a</code> 会在使用 <code>a</code> 之前自增它的值。递减运算符也会发生类似的情况。</p>
<h2 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h2>
<p>关系运算符用于比较两个数的值，返回 0 (false) 或 1 (true)</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center">Less than</td>
<td style="text-align:center"><code>a &lt; b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center">Greater than</td>
<td style="text-align:center"><code>a &gt; b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center">Less than or equal to</td>
<td style="text-align:center"><code>a &lt;= b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center">Greater than or equal to</td>
<td style="text-align:center"><code>a &gt;= b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">Equal to</td>
<td style="text-align:center"><code>a == b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">Not equal to</td>
<td style="text-align:center"><code>a != b</code></td>
</tr>
</tbody>
</table>
<p>浮点数的精度是有限的，因此在比较两个浮点数是否相等时，应该使用一个小的误差范围来判断，而不是直接使用 <code>==</code> 操作符。</p>
<h2 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h2>
<p>逻辑运算符用于组合两个或两个以上条件，结果返回一个布尔值。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">Logical AND</td>
<td style="text-align:center"><code>a &amp;&amp; b</code></td>
</tr>
<tr>
<td style="text-align:center">||</td>
<td style="text-align:center">Logical OR</td>
<td style="text-align:center">a || b</td>
</tr>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center">Logical NOT</td>
<td style="text-align:center"><code>!a</code></td>
</tr>
</tbody>
</table>
<h2 id="按位运算符"><a class="markdownIt-Anchor" href="#按位运算符"></a> 按位运算符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">Bitwise AND</td>
<td style="text-align:center"><code>a &amp; b</code></td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">Bitwise OR</td>
<td style="text-align:center">a | b</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">Bitwise XOR</td>
<td style="text-align:center"><code>a ^ b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center">Bitwise First Complement</td>
<td style="text-align:center"><code>~a</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center">Bitwise Leftshift</td>
<td style="text-align:center"><code>a &lt;&lt; b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center">Bitwise Rightshilft</td>
<td style="text-align:center"><code>a &gt;&gt; b</code></td>
</tr>
</tbody>
</table>
<p>注意：只有 char 和 int 数据类型可以与 Bitwise 运算符一起使用。</p>
<h2 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center">Simple Assignment</td>
<td style="text-align:center"><code>a = b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>+=</code></td>
<td style="text-align:center">Plus and assign</td>
<td style="text-align:center"><code>a += b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-=</code></td>
<td style="text-align:center">Minus and assign</td>
<td style="text-align:center"><code>a -= b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>*=</code></td>
<td style="text-align:center">Multiply and assign</td>
<td style="text-align:center"><code>a *= b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>/=</code></td>
<td style="text-align:center">Divide and assign</td>
<td style="text-align:center"><code>a /= b</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%=</code></td>
<td style="text-align:center">Modulus and assign</td>
<td style="text-align:center"><code>a %= b</code></td>
</tr>
</tbody>
</table>
<h2 id="三元运算符"><a class="markdownIt-Anchor" href="#三元运算符"></a> 三元运算符</h2>
<p>条件运算符也被称为三元运算符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(expression) ? value_if_true : value_if_false;</span><br></pre></td></tr></table></figure>
<p><code>?</code> 运算符首先检查给定的条件，如果条件为真，则执行第一个表达式，否则执行第二个表达式。它是 C++中 if-else 条件的替代方案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Conditional Operator</span></span><br><span class="line">    <span class="keyword">int</span> result = (a &lt; b) ? b : a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The greatest number is &quot;</span> &lt;&lt; result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sizeof"><a class="markdownIt-Anchor" href="#sizeof"></a> sizeof</h2>
<p><code>sizeof</code> 是一个运算符，它以字节为单位计算变量或者数据类型的大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">37</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(age));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态转换"><a class="markdownIt-Anchor" href="#静态转换"></a> 静态转换</h2>
<p>注意，整数运算只能得到结果的整数部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> / <span class="number">3</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>因此需要强制转换类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(a) / b; <span class="comment">// 0.3333333</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">float</span>)a / b; <span class="comment">// 0.3333333</span></span><br></pre></td></tr></table></figure>
<p>静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。</p>
<h1 id="标准输入输出"><a class="markdownIt-Anchor" href="#标准输入输出"></a> 标准输入输出</h1>
<h3 id="cstdio"><a class="markdownIt-Anchor" href="#cstdio"></a> cstdio</h3>
<p><code>&lt;cstdio&gt;</code> 是 C++ 标准库中的一个头文件，它包含了 C 语言标准 I/O 库的 C++ 封装，主要用于文件的输入和输出操作。我们通常会使用 <code>scanf</code>和 <code>printf</code> 函数进行标准输入输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter your age: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reads an integer</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prints the age</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Age is: %d\n&quot;</span>, age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>printf()</code> 格式控制符的完整形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">%[flag][width][.precision]type</span><br></pre></td></tr></table></figure>
<p>type 表示输出类型，width 表示最小输出宽度，当输出结果的宽度不足时，默认会在左边补齐空格。precision 表示输出精度，也就是小数的位数。用于整数时，precision 表示最小输出宽度，整数的宽度不足时会在左边补 0，用于字符串时，precision 表示最大输出宽度。</p>
<h3 id="iostream"><a class="markdownIt-Anchor" href="#iostream"></a> iostream</h3>
<p><code>&lt;iostream&gt;</code>库是 C++ 标准库中用于输入输出操作的头文件。其中定义了几个常用的流类和操作符：</p>
<ul>
<li><code>std::cin</code> 标准输入流</li>
<li><code>std::cout</code> 标准输出流</li>
<li><code>std::cerr</code> 非缓冲标准错误流</li>
<li><code>std::clog</code> 缓冲标准日志流。</li>
</ul>
<p>同时，重载的输入输出运算符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 可以自行分析所处理的数据类型，无需像使用 <code>scanf</code> 和 <code>printf</code> 函数那样给出格式控制字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your age:&quot;</span>;  <span class="comment">// Output a label</span></span><br><span class="line">    cin &gt;&gt; age;  <span class="comment">// Taking input from user and store it in variable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Invalid input!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Age entered: &quot;</span> &lt;&lt; age &lt;&lt; endl;  <span class="comment">// Output the entered age</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>endl</code> 用于在行末添加一个换行符 <code>\n</code> 。</p>
<p>注意，在使用 <code>cin</code> 将文本作为输入时，一旦遇到空格、制表符或换行符就会停止读取输入。使用标准库 <code>&lt;string&gt;</code> 中的 <code>getline</code>函数可以读取包含空格的整行输入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string fullName;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your full name: &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, fullName);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; fullName &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h1>
<h2 id="条件语句"><a class="markdownIt-Anchor" href="#条件语句"></a> 条件语句</h2>
<h3 id="if-else"><a class="markdownIt-Anchor" href="#if-else"></a> if-else</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">13</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;child&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">1</span> <span class="keyword">and</span> age &lt;= <span class="number">18</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Growing stage&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;adult&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch-case"><a class="markdownIt-Anchor" href="#switch-case"></a> switch-case</h3>
<p>在 C++中，当主要根据变量或表达式的值来评估多种情况时，就会使用 switch-case</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string gender = <span class="string">&quot;Male&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (gender) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Male&quot;</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Gender is Male&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Female&quot;</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Gender is Female&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value can be Male or Female&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<code>case</code>语句并没有花括号<code>&#123;&#125;</code>，如果遗漏了<code>break</code>，后续语句将全部执行，直到遇到<code>break</code>语句。</p>
</blockquote>
<h2 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h2>
<h3 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (n &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">    sum = sum + n;</span><br><span class="line">    n ++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum; <span class="comment">// 5050</span></span><br></pre></td></tr></table></figure>
<h3 id="do-while"><a class="markdownIt-Anchor" href="#do-while"></a> do-while</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    sum = sum + n;</span><br><span class="line">    n ++;</span><br><span class="line">&#125; <span class="keyword">while</span> (n &lt;= <span class="number">100</span>);</span><br><span class="line">cout &lt;&lt; sum;  <span class="comment">// 5050</span></span><br></pre></td></tr></table></figure>
<h3 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h3>
<p><code>for</code> 循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum;</span><br></pre></td></tr></table></figure>
<p>还有一种基于范围的 <code>for</code> 循环，不需要条件和更新语句。它只能用于可迭代的对象，如向量、集合等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using range based for loop to print vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i: v) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无限循环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is an infinite for loop as the condition expression is blank</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This loop will run forever.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳转语句"><a class="markdownIt-Anchor" href="#跳转语句"></a> 跳转语句</h2>
<h3 id="break"><a class="markdownIt-Anchor" href="#break"></a> break</h3>
<p><code>break</code> 语句用于完全终止循环或 <code>switch</code> 语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// if i become 3 then break the loop and move to next statement out of loop</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next statements</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="continue"><a class="markdownIt-Anchor" href="#continue"></a> continue</h3>
<p><code>continue</code> 语句用于跳过当前迭代并继续下一个迭代</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// if i become 3 then skip the rest body of loop and move next iteration</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指针和引用"><a class="markdownIt-Anchor" href="#指针和引用"></a> 指针和引用</h1>
<h2 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h2>
<p>在讲解指针之前，先来了解下内存（memory）的概念。内存是最重要的硬件之一，是用来存储数据的。内存的最小单位是字节（byte，1byte=8bit），每个字节都有一个唯一的地址（类似储物柜的编号），程序可以通过这个地址访问内存中的数据。</p>
<p>指针（Pointer）是一个存储内存地址的变量，它所存储的值是内存中某个位置的地址。使用指针的主要原因是操作方便、效率高。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/pointer-in-c.png" style="zoom:67%;" />
<p>我们可以使用<strong>引用运算符</strong> <code>&amp;</code> 获取内存中该变量的地址，将该地址赋给一个指针变量。声明指针变量的语法不同，需要在其名称前加上星号 <code>*</code> ，指针变量的类型是其指向的的变量类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span>* ptr = &amp;age;  <span class="comment">// 0x7ffeef7dcb9c</span></span><br></pre></td></tr></table></figure>
<p>指针的<strong>解引用运算符</strong> <code>*</code> 可以获取和修改该地址指向的变量的值。注意，解引用运算符和声明指针时前面加的星号含义是不同的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// declare pointer variable</span></span><br><span class="line">    <span class="keyword">int</span>* ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note that data type of ptr and var must be same</span></span><br><span class="line">    ptr = &amp;var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign the address of a variable to a pointer</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value at ptr = &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value at var = &quot;</span> &lt;&lt; var &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value at *ptr = &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value at ptr = 0x7ffe454c08cc</span><br><span class="line">Value at var = 20</span><br><span class="line">Value at *ptr = 20</span><br></pre></td></tr></table></figure>
<h2 id="指针运算"><a class="markdownIt-Anchor" href="#指针运算"></a> 指针运算</h2>
<p>指针的 <code>+/-</code> 运算相当于移动指针，常用在数组中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *ptr;</span><br><span class="line">ptr = &amp;a[<span class="number">0</span>];</span><br><span class="line">ptr += <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<img title="" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/Pointer-Addition.webp" width="449" data-align="center">
<p>两指针的差值为指针相隔元素的个数。</p>
<h2 id="指针的指针"><a class="markdownIt-Anchor" href="#指针的指针"></a> 指针的指针</h2>
<p>由于指针也是变量，也有存储地址，同样也可以定义另一个指针指向该指针，称为指针的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> **ptr2 = &amp;ptr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**ptr = %d&quot;</span>, *ptr); <span class="comment">// **ptr = 20</span></span><br></pre></td></tr></table></figure>
<img title="" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/double-pointers-in-c.webp" width="539" data-align="center">
<h2 id="空指针"><a class="markdownIt-Anchor" href="#空指针"></a> 空指针</h2>
<p>在指针变量声明的时候，如果没有确切的地址可以赋值，建议赋值为 NULL 。NULL 指针是一个定义在标准库中的值为零的常量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr2 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。如需检查一个空指针，可以使用 if 语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr)</span><br><span class="line"><span class="keyword">if</span>(!ptr)</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2>
<p>引用（Reference）是 C++ 相对于 C 语言的又一个扩充。引用可以看做是同一份内存的别名。引用的声明方式类似于指针，在变量名前加上 <code>&amp;</code> 。引用必须在定义的同时初始化，并且以后也不能再引用其它数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ref is a reference to x.</span></span><br><span class="line">    <span class="keyword">int</span>&amp; ref = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value of x is now changed to 20</span></span><br><span class="line">    ref = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value of x is now changed to 30</span></span><br><span class="line">    x = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，引用不需要运算符 <code>*</code> 即可访问值。它们可以像普通变量一样使用。仅在声明时需要 <code>&amp;</code> 运算符。</p>
<p>我们在循环中使用引用来修改所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vect&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can modify elements if we use reference</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x : vect) &#123;</span><br><span class="line">        x = x + <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="派生数据类型"><a class="markdownIt-Anchor" href="#派生数据类型"></a> 派生数据类型</h1>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<h3 id="声明和初始化"><a class="markdownIt-Anchor" href="#声明和初始化"></a> 声明和初始化</h3>
<p>在 C++ 中，数组是一种数据结构，用于将相同数据类型存储在连续的内存位置。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/c-array-declaration.png"  width="407">
<p>在 C++ 中，我们只需先指定数据类型，然后指定数组的名称及其大小即可声明数组。不允许使用变量定义数组大小，数组一旦创建后，大小就不可改变。</p>
<p>你可以在声明数组之后为其赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  arr[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在声明数组的时候进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>如果我们已经用值初始化了数组，但没有声明数组的长度，则数组的长度等于大括号内的元素数量。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/C-array-initialization.png" width="409">
<p>我们也可以初始化部分数组，其余元素为默认值：整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>在 C++ 中，我们没有像 Java 中那样的 length 函数来查找数组大小，但我们可以使用 <code>sizeof</code> 运算符计算数组的大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Length of an array</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="数组与指针"><a class="markdownIt-Anchor" href="#数组与指针"></a> 数组与指针</h3>
<p>数组可以通过索引来访问、修改元素，索引从<code>0</code>开始。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>在 C++ 中，数组和指针彼此密切相关。数组名其实是一个指针常量，它存储的是数组中首个元素的地址，即 <code>arr</code> 和 <code>&amp;arr[0]</code> 是等价的。因此，可以像普通指针一样使用数组名。</p>
<img title="" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/random_access_in_array.png" width="538" data-align="center">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Program to Illustrate that Array Name is a Pointer</span></span><br><span class="line"><span class="comment">// that Points to First Element of the Array</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Defining an array</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define a pointer</span></span><br><span class="line">    <span class="keyword">int</span>* ptr = arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Printing address of the arrary using array name</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Memory address of arr: &quot;</span> &lt;&lt; &amp;arr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Printing address of the array using ptr</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Memory address of arr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Memory address of arr: 0x7fff2f2cabb0</span><br><span class="line">Memory address of arr: 0x7fff2f2cabb0</span><br></pre></td></tr></table></figure>
<p>上例中，我们能够将 <code>arr</code> 分配给 <code>ptr</code>，因为 <code>arr</code> 也是一个指针。之后，我们使用引用运算符 <code>&amp;</code> 打印 <code>arr</code> 的内存地址，并打印存储在指针 <code>ptr</code> 中的地址，我们可以看到 <code>arr</code> 和 <code>ptr</code>，它们都存储相同的内存地址。</p>
<p>现在，我们可以仅使用数组名称访问数组的元素，即 <code>*(arr + i)</code> 等价于 <code>arr[i]</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Second element: &quot;</span> &lt;&lt; *(arr + <span class="number">1</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h3>
<p>使用最广泛的多维数组是 2D 数组和 3D 数组。这些数组通常以行和列的形式表示。</p>
<img title="" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/dimensions_of_array.png" width="482" data-align="center">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure>
<p>访问二维数组的某个元素需要使用行和列两个索引： <code>array[row][col]</code>。</p>
<p>二维数组由多个一位数组组成，数组名 <code>arr</code> 代表二维数组首地址，也代表第 0 行首地址，<code>arr + 1</code> 代表第 1 行首地址，依次类推。一般 <code>arr[i] + j</code> 代表第<code>i</code>行第<code>j</code>列元素地址，即 <code>&amp;arr[i][j]</code>。</p>
<h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2>
<p>C 语言中字符串并不是一种基本数据，实际上是一个以 <code>\0</code> 结尾的字符数组。以下是 C 中定义的字符串的内存表示：</p>
<img title="" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/strings-and-pointers.webp" alt="" width="428" data-align="center">
<p>可以像初始化一个普通的数组那样初始化一个字符串，或者使用更加方便的字符串常量表示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>字符串使用<strong>双引号</strong>表示时，编译器会在初始化时自动追加一个 <code>\0</code></p>
</blockquote>
<p>C++ 除了可以使用 C 风格的字符串，还可以使用标准库 <code>&lt;string&gt;</code> 中的 <code>std::string</code> 类。它是对 C 风格字符串的封装，提供了更安全、更易用的字符串操作功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello, world!&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>string 字符串也可以像 C 风格的字符串一样按照下标来访问其中的每一个字符，起始下标仍是从 0 开始。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;First character: &quot;</span> &lt;&lt; str[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>支持使用 <code>+</code> 或 <code>+=</code> 运算符来直接拼接 string 字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">string result = str1 + str2;</span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h2>
<h3 id="定义和使用"><a class="markdownIt-Anchor" href="#定义和使用"></a> 定义和使用</h3>
<p>结构体是一种自定义的数据类型，用于创建复杂的数据结构，他可以包含多个不同类型的成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> [<span class="title">tag</span>] &#123;</span></span><br><span class="line">    member-list;</span><br><span class="line">    member-list;</span><br><span class="line">    member-list;</span><br><span class="line">    ...</span><br><span class="line">&#125; [variable-list];</span><br></pre></td></tr></table></figure>
<p>可以先定义结构体类型，再声明结构体变量；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>], sex;</span><br><span class="line">    <span class="keyword">float</span> score[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Alice</span>, <span class="title">Bob</span>;</span></span><br></pre></td></tr></table></figure>
<p>也可以直接声明变量，同时省略结构体名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>], sex;</span><br><span class="line">    <span class="keyword">float</span> score[<span class="number">3</span>];</span><br><span class="line">&#125; Alice, Bob;</span><br></pre></td></tr></table></figure>
<p>可以在声明的时候初始化一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Alice</span> =</span> &#123; <span class="number">18</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&#x27;F&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>结构体通过点语法来访问和修改成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s, age %d&quot;</span>, Alice.name, Alice.age);</span><br></pre></td></tr></table></figure>
<h3 id="内嵌结构体"><a class="markdownIt-Anchor" href="#内嵌结构体"></a> 内嵌结构体</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>], sex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> year, month, day;</span><br><span class="line">    &#125; birthday;</span><br><span class="line">    <span class="keyword">float</span> score[<span class="number">3</span>];</span><br><span class="line">&#125; Alice, Bob;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// age, name, sex, year, month, day, score[0], score[1], score[2]</span></span><br><span class="line">Alice = &#123;<span class="number">16</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">2024</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">83.6</span>, <span class="number">88.5</span>, <span class="number">90</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体指针"><a class="markdownIt-Anchor" href="#结构体指针"></a> 结构体指针</h3>
<p>像原始类型一样，我们可以有指向结构体的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">ptr</span> =</span> &amp;Alice;</span><br></pre></td></tr></table></figure>
<p>结构体指针必须使用 <code>-&gt;</code> 运算符访问结构体的成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ptr-&gt;age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<h3 id="结构体数组"><a class="markdownIt-Anchor" href="#结构体数组"></a> 结构体数组</h3>
<p>与其他原始数据类型一样，我们可以创建一个结构体数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>[5];</span></span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h2>
<p>枚举 （Enumerated ） 是用户定义的数据类型，可以为其分配一些有限的值。这些值由用户在声明时定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Defining enum Gender</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> &#123;</span> MALE, FEMALE &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating Gender type variable</span></span><br><span class="line">    Gender gender = MALE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (gender) &#123;</span><br><span class="line">    <span class="keyword">case</span> MALE:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Gender is Male&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FEMALE:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Gender is Female&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value can be Male or Female&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C/C++ 中，将枚举值作为 <code>int</code> 连续值来处理。默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值。</p>
<h2 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h2>
<p>C/C++ 语言允许使用 <code>typeof</code> 关键字对数据类型赋予一个新名字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>[] STRING;</span><br><span class="line">STRING name = <span class="string">&quot;Alice&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>使用 <code>typedef</code>，我们可以简化处理结构体时的代码。声明变量的时候不需要 struct 关键字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> year, month, day;</span><br><span class="line">&#125; DATE;</span><br><span class="line"></span><br><span class="line">DATE birthday = &#123; <span class="number">2024</span>, <span class="number">6</span>, <span class="number">16</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>C++11 引入 using 关键字为现有类型定义别名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">char</span>[] = STRING;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<p>函数允许用户将程序划分为多个模块，每个模块执行特定任务。</p>
<h2 id="定义和调用"><a class="markdownIt-Anchor" href="#定义和调用"></a> 定义和调用</h2>
<p>函数定义包括返回类型、函数名、参数列表和函数体。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main function that doesn&#x27;t receive any parameter and returns integer</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calling above function to find max of &#x27;a&#x27; and &#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">max</span>(a, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m is &quot;</span> &lt;&lt; m;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中 <code>int</code> 为函数返回值类型，如无返回值，以 <code>void</code> 类型表示，函数返回值用 <code>return</code> 显示给出。如无返回值，我们仍然可以使用 <code>return</code> 语句终止函数。</p>
<h2 id="前向声明"><a class="markdownIt-Anchor" href="#前向声明"></a> 前向声明</h2>
<p>由于 C++ 程序按照代码的书写顺序执行，因此在函数调用之前必须先声明。函数声明告诉编译器参数的数量、参数的数据类型以及返回函数的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数声明的时候可以只写参数类型，省略参数名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;  <span class="comment">// Function declaration with parameter names</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">int</span>)</span></span>;     <span class="comment">// Function declaration without parameter names</span></span><br></pre></td></tr></table></figure>
<h2 id="参数传递"><a class="markdownIt-Anchor" href="#参数传递"></a> 参数传递</h2>
<p>函数在定义时预期接收的参数称为<strong>形式参数</strong>，函数调用时实际传入的参数称为<strong>实际参数</strong>。C++ 支持三种参数传递方法：</p>
<ul>
<li><strong>值传递</strong>：函数调用的时候会把实参的值拷贝一份传给函数内部，并不会影响到函数外部。C++默认方法。</li>
<li><strong>指针传递</strong>：函数调用的时候会把实参的地址传递给函数，在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</li>
<li><strong>引用传递</strong>：函数调用的时候传递实参的引用。在函数内，对引用的操作会直接作用于实际参数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass by Value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass by Pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass by Reference</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before swap: x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap1</span>(x, y); <span class="comment">// a = 20, b = 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pass by Value: x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap2</span>(&amp;x, &amp;y); <span class="comment">// *a = 20, *b = 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pass by Pointer: x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap3</span>(x, y); <span class="comment">// a = 10, b = 20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pass by Reference: x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Before swap: x = 10, y = 20</span><br><span class="line">Pass by Value: x = 10, y = 20</span><br><span class="line">Pass by Pointer: x = 20, y = 10</span><br><span class="line">Pass by Reference: x = 10, y = 20</span><br></pre></td></tr></table></figure>
<p>在 C++ 中，数组名实质上是指针，数组参数在传递的函数中都被视为指针。有两种数组参数传递方式：</p>
<ul>
<li>将数组名称作为指针参数传递， 如 <code>int* arr</code></li>
<li>函数使用简单的数组声明接受数组，如 <code>int arr[]</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinSized</span><span class="params">(<span class="keyword">int</span> arr[<span class="number">5</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinUnsized</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinPointer</span><span class="params">(<span class="keyword">int</span>* arr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// driver code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ar[<span class="number">5</span>] = &#123; <span class="number">30</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">printMin</span>(ar); <span class="comment">// passing array to function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// passing array as a sized array argument</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinUnsized</span><span class="params">(<span class="keyword">int</span> arr[<span class="number">5</span>], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; arr[i]) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum element is: &quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// passing array as an unsized array argument</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinUnsized</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; *(arr + i)) &#123;</span><br><span class="line">            min = *(arr + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum element is: &quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Passing array as a pointer argument</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinPointer</span><span class="params">(<span class="keyword">int</span>* ptr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = ptr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; ptr[i]) &#123;</span><br><span class="line">            min = ptr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum element is: &quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认参数"><a class="markdownIt-Anchor" href="#默认参数"></a> 默认参数</h2>
<p>在 C++ 中，定义函数时可以给形参指定一个默认的值，默认参数只能放在形参列表的最后。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function with default height &#x27;h&#x27; argument</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> h = <span class="number">10.0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l * h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Uses default height</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">calcArea</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Uses custom height</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">calcArea</span>(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数是单独声明和定义的，则参数的默认值必须在声明中，且声明默认参数后，无法在函数定义中修改它们。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declaration with default argument</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition without default argument</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命令行参数"><a class="markdownIt-Anchor" href="#命令行参数"></a> 命令行参数</h2>
<p>在 C++ 程序中，命令行参数是使用 <code>main()</code> 函数参数来接收的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>argc</code> 是指传入参数的个数，<code>argv[]</code> 是一个指针数组，指向传递给程序的每个参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Printing the coundt of arguments</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The value of argc is %d\n&quot;</span>, argc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prining each argument</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应当指出的是，<code>argv[0]</code> 存储程序的名称，如果没有提供任何参数，<code>argc</code> 将为 1。多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号或单引号内部。</p>
<h2 id="返回指针的函数"><a class="markdownIt-Anchor" href="#返回指针的函数"></a> 返回指针的函数</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">createArray</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[size]; <span class="comment">// Dynamically allocate memory for an array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>; <span class="comment">// Initialize array elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr; <span class="comment">// Return the pointer to the array</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* myArray = <span class="built_in">createArray</span>(size); <span class="comment">// Function returns a pointer to the array</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; myArray[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] myArray; <span class="comment">// Don&#x27;t forget to free the allocated memory</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归函数"><a class="markdownIt-Anchor" href="#递归函数"></a> 递归函数</h2>
<p>函数直接或间接调用自身，直到满足给定条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calculate the sum of first N natural numbers using recursion</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nSum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base condition to terminate the recursion when N = 0</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursive case / recursive call</span></span><br><span class="line">    <span class="keyword">int</span> res = n + nSum(n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calling the function</span></span><br><span class="line">    <span class="keyword">int</span> sum = nSum(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum of First %d Natural Numbers: %d&quot;</span>, n, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h2>
<p>在 C 语言中，函数其实也可以看作一种数据类型，函数的类型其实就是它的返回值和参数列表。我们可以定义一个函数指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*ptr)(<span class="keyword">int</span>*, <span class="keyword">int</span>*);</span><br><span class="line">ptr = swap;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>ptr</code> 就是一个函数指针， <code>*ptr</code> 就代表该函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*<span class="built_in">ptr</span>(&amp;x, &amp;y);</span><br></pre></td></tr></table></figure>
<p>函数指针的应用也是非常广泛的，比如在实现一个回调函数的时候，就可以把函数指针作为参数传递给另一个函数，然后在这个函数里使用函数指针来使用函数，这种方式可以让代码更加灵活。</p>
<p>这里，我们有 c++ 示例，用于访问数组中的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function declarations</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Declare and initialize an array of function pointers</span></span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*funcArray[<span class="number">3</span>])(<span class="keyword">int</span>, <span class="keyword">int</span>) = &#123; add, subtract, multiply &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Variables to use as function parameters</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>, y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access and call the functions using the array of function pointers</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Add: &quot;</span> &lt;&lt; funcArray[<span class="number">0</span>](x, y) &lt;&lt; endl;       <span class="comment">// Calls add(10, 5)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Subtract: &quot;</span> &lt;&lt; funcArray[<span class="number">1</span>](x, y) &lt;&lt; endl;  <span class="comment">// Calls subtract(10, 5)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Multiply: &quot;</span> &lt;&lt; funcArray[<span class="number">2</span>](x, y) &lt;&lt; endl;  <span class="comment">// Calls multiply(10, 5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数重载"><a class="markdownIt-Anchor" href="#函数重载"></a> 函数重载</h2>
<p>C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading）。调用时根据实参和形参的匹配选择最佳函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> a + b + c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">12</span>, <span class="number">20</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板函数"><a class="markdownIt-Anchor" href="#模板函数"></a> 模板函数</h2>
<p>C++ 支持将数据类型作为参数传递，这样我们就不需要为不同的数据类型编写相同的代码。这个函数就称为函数模板（Function Template）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br></pre></td></tr></table></figure>
<p><code>template</code> 和 <code>typename</code> 是定义函数模板的关键字，它后面尖括号里的 <code>T</code> 是类型占位符。<code>typename T</code> 告诉编译器：字母 T 将在接下来的函数里代表一种不确定的数据类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// One function works for all data types. This would work</span></span><br><span class="line"><span class="comment">// even for user defined types if operator &#x27;&gt;&#x27; is overloaded</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">myMax</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Call myMax for int</span></span><br><span class="line">    cout &lt;&lt; myMax&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// call myMax for double</span></span><br><span class="line">    cout &lt;&lt; myMax&lt;<span class="keyword">double</span>&gt;(<span class="number">3.0</span>, <span class="number">7.0</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// call myMax for char</span></span><br><span class="line">    cout &lt;&lt; myMax&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;e&#x27;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像普通参数一样，我们可以将多个数据类型作为参数传递给模板，也可以为模板指定默认参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Program to implement use of template</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span> =</span> <span class="keyword">char</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T x, U y)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Function Called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// This will call func&lt;char, char&gt;</span></span><br><span class="line">    func&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lambda-表达式"><a class="markdownIt-Anchor" href="#lambda-表达式"></a> lambda 表达式</h2>
<p>C++ 11 引入了 lambda 表达式。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture] (parameters) -&gt; <span class="keyword">return</span>-type&#123;body&#125;</span><br></pre></td></tr></table></figure>
<p>通常，lambda 表达式中的 retur-type 由编译器本身计算，我们不需要显式指定它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> (a &lt; b) ? b : a ; &#125;</span><br></pre></td></tr></table></figure>
<p><code>[]</code> 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数体中可以使用的外部变量。</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[]</code></td>
<td>空方括号表示不导入任何外部变量</td>
</tr>
<tr>
<td><code>[=]</code></td>
<td>表示以值传递的方式导入所有外部变量</td>
</tr>
<tr>
<td><code>[&amp;]</code></td>
<td>表示以引用传递的方式导入所有外部变量</td>
</tr>
<tr>
<td><code>[x, &amp;y]</code></td>
<td><code>x</code> 以传值方式导入，<code>y</code> 以引用方式导入</td>
</tr>
<tr>
<td><code>[&amp;, x]</code></td>
<td><code>x</code> 以值传递方式导入，其余变量以引用方式导入</td>
</tr>
<tr>
<td><code>[=, &amp;x]</code></td>
<td><code>x</code> 以引用方式导入，其余变量以值传递方式导入</td>
</tr>
</tbody>
</table>
<p>小括号可以接收外部传递的多个参数，和普通函数不同的是，如果不需要传递参数，可以连同 <code>()</code> 小括号一起省略可变参数</p>
<h1 id="动态内存管理"><a class="markdownIt-Anchor" href="#动态内存管理"></a> 动态内存管理</h1>
<p>在 C/C++中内存可分为两种类型：</p>
<ul>
<li><strong>栈内存</strong>：（stack）一般用来存储局部变量和函数的参数，它的分配和释放由编译器自动完成；</li>
<li><strong>堆内存</strong>：（heap）堆内存比栈内存要大得多，但是它的分配和释放需要手动完成。是所有程序共同拥有的自由内存。</li>
</ul>
<img title="" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/Memory-Layout-of-C-Program.webp" alt="Memory-Layout-of-C-Program" width="520" data-align="center">
<p>C 标准库 <code>&lt;cstdlib&gt;</code> 为内存的分配和管理提供了四个函数</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void* calloc(int num, int size)</code></td>
<td>分配一个 num 个元素的数组，每个元素的大小为 size 字节，返回指针</td>
</tr>
<tr>
<td><code>void free(void *address)</code></td>
<td>释放 address 所指向的内存块</td>
</tr>
<tr>
<td><code>void* malloc(int num)</code></td>
<td>配一个 num 字节的内存块，返回指针</td>
</tr>
<tr>
<td><code>void* realloc(void *address, int newsize)</code></td>
<td>重新分配内存，把内存扩展到 newsize，返回指针</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：void* 类型表示未确定类型的指针。C/C++ 规定 void* 类型可以通过类型转换强制转换为任何其它类型的指针。<br />
在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * <span class="number">10</span>);</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure>
<p>C++ 又新增了两个关键字 <code>new</code> 和<code>delete</code> 来更加简单的分配内存。<code>new</code> 操作符会根据后面的数据类型来推断所需空间的大小。<code>delete</code> 用来释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure>
<p>如果希望使用一组连续的内存，可以使用 <code>new</code> 来分配，使用 <code>delete[]</code> 来释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure>
<p>在实际开发中，<code>new</code> 和 <code>delete</code> 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。</p>
<h1 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h1>
<p>C++ 是一种功能强大的高级编程语言，它在 C 语言的基础上增加了面向对象编程的特性。</p>
<h2 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象"></a> 类与对象</h2>
<p>类（class）是一种用户定义的数据类型，它包含自己的属性和方法，可以通过创建该类的实例来访问和使用它们。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define a class named &#x27;Person&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Data members</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Member Functions</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parameterized Constructor</span></span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">      <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::introduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hi, my name is &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; and I am &quot;</span></span><br><span class="line">         &lt;&lt; age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中 <code>Person</code>是类名称，类名的首字母一般大写。<code>&#123; &#125;</code>内部是类所包含的属性和方法，它们统称为类的成员（Member）。定义类外面的方法必须使用域解析符 <code>::</code>指明当前函数所属的类。</p>
<p>创建对象以后，可以使用点号<code>.</code>来访问属性和方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create an object of the Person class</span></span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;18&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accessing data members</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; person.name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the introduce member method</span></span><br><span class="line">    person.<span class="built_in">introduce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C++ 中，指向类的指针与指向结构的指针类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person* ptr = &amp;person;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accessing data members</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; ptr-&gt;name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the introduce member method</span></span><br><span class="line">    ptr-&gt;<span class="built_in">introduce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h2>
<p>C++ 通过访问修饰符 <code>public, protected, private</code> 来控制类属性和方法的访问权限。</p>
<ul>
<li><code>public</code>：类的所有成员都是公开的，可以在任何地方访问。</li>
<li><code>protected</code>：类成员可以被类及其子类访问。</li>
<li><code>private</code>：类成员只能在类的内部访问，默认修饰符。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// private member</span></span><br><span class="line">    <span class="keyword">float</span> area;</span><br><span class="line">    <span class="keyword">float</span> radius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getRadius</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter radius\n&quot;</span>;</span><br><span class="line">        cin &gt;&gt; radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        area = <span class="number">3.14</span> * radius * radius;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Area of circle=&quot;</span> &lt;&lt; area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// creating instance(object) of class</span></span><br><span class="line">    Circle cir;</span><br><span class="line">    cir.<span class="built_in">getRadius</span>();</span><br><span class="line">    cir.<span class="built_in">findArea</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h2>
<p>构造函数（Constructor）是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，并且不需要 <code>void</code> 声明。一个类可以有多个重载的构造函数。如果用户没有定义，编译器会自动生成一个默认的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Declaration of parameterized constructor</span></span><br><span class="line">    <span class="built_in">Person</span>(string, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameterized constructor outside class</span></span><br><span class="line">Person::<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h2>
<p>析构函数（Destructor）是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（<code>~</code>）作为前缀，它不会返回任何值，也不能带有任何参数。如果用户没有定义，编译器会自动生成一个默认的析构函数。</p>
<p>C++ 中的 <code>new</code> 和 <code>delete</code> 分别用来分配和释放内存，它们与 C 语言中 <code>malloc()</code>、<code>free()</code> 最大的一个不同之处在于：用 <code>new</code> 分配内存时会调用构造函数，用 <code>delete</code> 释放内存时会调用析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// User-Defined Constructor</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;\n Constructor executed&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// User-Defined Destructor</span></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;\nDestructor executed&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="this-指针"><a class="markdownIt-Anchor" href="#this-指针"></a> this 指针</h2>
<p><code>this</code> 是 C++ 类中的隐式形参，它是指向当前对象的指针，通过它可以访问当前对象的所有成员，包括 <code>public, protected, private</code> 权限的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parameterized Constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(string name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">      <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，<code>this</code> 是一个指针，要用 <code>-&gt;</code> 来访问属性和方法。本例中类方法的参数和属性重名，只能通过 <code>this</code> 区分。</p>
<h2 id="友元函数"><a class="markdownIt-Anchor" href="#友元函数"></a> 友元函数</h2>
<p>友元函数不是类的成员函数，通过在类内使用关键字 <code>friend</code> 来声明，可以访问当前类中的所有成员，包括 <code>public, protected, private</code> 权限的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">displayAge</span><span class="params">(Person&amp; person)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAge</span><span class="params">(Person&amp; person)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; person.age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2>
<p>继承（Inheritance）允许一个派生类继承基类的属性和方法。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://warehouse-1310574346.cos.ap-shanghai.myqcloud.com/images/CPP/inheritance-660x454.png" alt="Inheritance in C++ with Example" width="379" data-align="center">
<p>在 C++中，有 3 种继承模式：<code>public, protected, private</code> ，用来指明基类成员在派生类中的最高访问权限。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++ 中基类的构造函数不能被继承，编译器会自动按照继承顺序调用基类的默认构造函数，这意味着将首先调用基类构造函数，然后调用派生类构造函数。基类的参数化构造函数则必须在派生类构造函数的初始化列表中显式调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// base class constructor</span></span><br><span class="line">    <span class="built_in">Parent</span>() &#123; cout &lt;&lt; <span class="string">&quot;Inside base class&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// sub class constructor</span></span><br><span class="line">    <span class="built_in">Child</span>() &#123; cout &lt;&lt; <span class="string">&quot;Inside sub class&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside base class</span><br><span class="line">Inside sub class</span><br></pre></td></tr></table></figure>
<h2 id="函数覆盖"><a class="markdownIt-Anchor" href="#函数覆盖"></a> 函数覆盖</h2>
<p>在 C++中，派生类会覆盖基类中相同类型的属性和方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ program for function overriding</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  base class declaration.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal makes a sound&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inheriting Animal class.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">    <span class="comment">// Override the sound method</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Dog dog = <span class="built_in">Dog</span>();</span><br><span class="line">    cout &lt;&lt; dog.name &lt;&lt; endl;</span><br><span class="line">    dog.<span class="built_in">sound</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载"><a class="markdownIt-Anchor" href="#运算符重载"></a> 运算符重载</h2>
<p>运算符重载（Operator Overloading）允许改变运算符的行为，以适应用户定义的类型。<code>operator</code> 关键字专门用于定义重载运算符的函数。虽然运算符重载所实现的功能完全可以用函数替代，但运算符重载使得程序的书写更加人性化，易于阅读。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> real, imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> i = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        real = r;</span><br><span class="line">        imag = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is automatically called when &#x27;+&#x27; is used with between two Complex objects</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(Complex <span class="keyword">const</span>&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex res;</span><br><span class="line">        res.real = real + obj.real;</span><br><span class="line">        res.imag = imag + obj.imag;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d + i%d\n&quot;</span>, real, imag); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An example call to &quot;operator+&quot;</span></span><br><span class="line">    Complex c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h2>
<p>虚函数允许我们使用基类的指针或引用调用任何派生类的方法，甚至可以在不知道派生类对象类型的情况下调用。虚拟函数是使用关键字 <code>virtual</code> 在基类中声明的方法，并在派生类中覆盖。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ program for virtual function overriding</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string attr = <span class="string">&quot;base&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;print base class&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;show base class&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string attr = <span class="string">&quot;derived&quot;</span>;</span><br><span class="line">    <span class="comment">// print () is already virtual function in</span></span><br><span class="line">    <span class="comment">// derived class, we could also declared as</span></span><br><span class="line">    <span class="comment">// virtual void print () explicitly</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;print derived class&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;show derived class&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* ptr;</span><br><span class="line">    Derived d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Point base class pointer to derived class object</span></span><br><span class="line">    ptr = &amp;d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Virtual function, binded at</span></span><br><span class="line">    <span class="comment">// runtime (Runtime polymorphism)</span></span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Non-virtual function, binded</span></span><br><span class="line">    <span class="comment">// at compile time</span></span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Accessing base class attributes</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base class attribute: &quot;</span> &lt;&lt; ptr-&gt;attr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">print derived <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">show</span> <span class="title">base</span> <span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">Base</span> <span class="keyword">class</span> <span class="title">attribute</span>:</span> base</span><br></pre></td></tr></table></figure>
<h2 id="类模板"><a class="markdownIt-Anchor" href="#类模板"></a> 类模板</h2>
<p>正如我们定义函数模板一样，我们也可以定义类模板。类模板在类定义独立于数据类型的内容时非常有用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Program to implement</span></span><br><span class="line"><span class="comment">// template Array class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(T arr[], <span class="keyword">int</span> s);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Array&lt;T&gt;::<span class="built_in">Array</span>(T arr[], <span class="keyword">int</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    ptr = <span class="keyword">new</span> T[s];</span><br><span class="line">    size = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        ptr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Array&lt;T&gt;::<span class="built_in">print</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *(ptr + i);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(arr, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类与头文件"><a class="markdownIt-Anchor" href="#类与头文件"></a> 类与头文件</h2>
<p>我们知道可以将函数声明放在头文件中。然后可以将这些函数声明<code>#include</code>到多个代码文件（甚至多个项目）中。类也不例外。类定义可以放在头文件中，然后<code>#include</code>在要使用类类型的任何其他文件中。</p>
<p>与只需要使用前向声明的函数不同，编译器通常需要查看类的完整定义，才能使用类型。这是因为编译器需要理解如何声明成员，以确保正确使用它们，并且它需要能够计算该类型的对象的大小，以便实例化它们。因此，头文件通常包含类的完整定义，而不仅仅是类的前向声明。</p>
<p>通常，类在与类同名的头文件中定义，在类之外定义的任何成员函数都放在与类相同名称的<code>.cpp</code>文件中。</p>
<p>这里是我们的 Date 类，分为 <code>.cpp</code> 和<code>.h</code> 文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_year&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_month&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_day&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_year; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDay</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_day; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Date::<span class="built_in">Date</span>(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day) <span class="comment">// 构造函数定义</span></span><br><span class="line">    : m_year&#123; year &#125;</span><br><span class="line">    , m_month&#123; month &#125;</span><br><span class="line">    , m_day&#123; day &#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Date::print</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// print 函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Date(&quot;</span> &lt;&lt; m_year &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_month &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_day &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，任何其他想要使用 Date 类的头文件或代码文件都可以简单地#include “Date.h” 。请注意，date.cpp 还需要编译到任何使用 date.h 的项目中，以便链接器可以将对成员函数的调用连接到其定义。</p>
<p><strong>最佳实践</strong>：优先将类定义放在与类同名的头文件中。琐碎的成员函数（例如访问函数、具有空函数体的构造函数等）可以在声明文件中定义。首选在与类同名的源文件中定义非平凡的成员函数。</p>
<h1 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h1>
<p>C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// Code that might throw an exception</span></span><br><span class="line">     <span class="keyword">throw</span> <span class="built_in">SomeExceptionType</span>(<span class="string">&quot;Error message&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>( ExceptionName e1 )  &#123;</span><br><span class="line">     <span class="comment">// catch block catches the exception that is thrown from try block</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>( ExceptionName e2 )  &#123;</span><br><span class="line">     <span class="comment">// catch block catches the exception that is thrown from try block</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in"><span class="keyword">catch</span></span>( ... )  &#123;</span><br><span class="line">     <span class="comment">// catch all exception</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当异常发生时，会立即终止当前函数并开始查找匹配的 catch 块来处理引发的异常。C++ 语言本身以及标准库中的函数抛出的异常，都是 exception 的子类，称为标准异常（Standard Exception）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// try block</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> numerator = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> denominator = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if denominator is 0 then throw runtime error.</span></span><br><span class="line">        <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(</span><br><span class="line">                <span class="string">&quot;Division by zero not allowed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate result if no exception occurs</span></span><br><span class="line">        res = numerator / denominator;</span><br><span class="line">        <span class="comment">// printing result after division</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Result after division: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch block to catch the thrown exception</span></span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> exception&amp; e) &#123;</span><br><span class="line">        <span class="comment">// print the exception</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Exception &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception Division by zero not allowed!</span><br></pre></td></tr></table></figure>
<h1 id="文件和流"><a class="markdownIt-Anchor" href="#文件和流"></a> 文件和流</h1>
<h2 id="cstdio-2"><a class="markdownIt-Anchor" href="#cstdio-2"></a> cstdio</h2>
<p>C 头文件 <code>&lt;cstdio&gt;</code> 包含了一个专门用来处理文件的数据类型 <code>FILE</code>。每当程序执行文件打开操作，其返回值是一个 <code>FILE</code> 类型的指针，所有关于文件的操作都要通过此指针来进行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE* <span class="title">fopen</span> <span class="params">(filename, mode)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C program to Open a File,</span></span><br><span class="line"><span class="comment">// Write in it, And Close the File</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Open file in write mode</span></span><br><span class="line">    FILE* file = <span class="built_in">fopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file is not opened. The program will exit now\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;Hello, this is a test file.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data written successfully.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the file</span></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fstream"><a class="markdownIt-Anchor" href="#fstream"></a> fstream</h2>
<p>在 C++ 中，<code>&lt;fstream&gt;</code> 是标准库中用于文件输入输出操作的类。它提供了一种方便的方式来读写文件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ program to Open a File,</span></span><br><span class="line"><span class="comment">// Write in it, And Close the File</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Creation of fstream class object</span></span><br><span class="line">    fstream fio;</span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// by default openmode = ios::in|ios::out mode</span></span><br><span class="line">    <span class="comment">// Automatically overwrites the content of file</span></span><br><span class="line">    fio.<span class="built_in">open</span>(<span class="string">&quot;sample.txt&quot;</span>, ios::trunc | ios::out | ios::in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute a loop If file successfully Opened</span></span><br><span class="line">    <span class="keyword">while</span> (fio) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read a Line from standard input</span></span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Press -1 to exit</span></span><br><span class="line">        <span class="keyword">if</span> (line == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write line in file</span></span><br><span class="line">        fio &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute a loop until EOF (End of File)</span></span><br><span class="line">    <span class="comment">// point read pointer at beginning of file</span></span><br><span class="line">    fio.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::beg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fio) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read a Line from File</span></span><br><span class="line">        <span class="built_in">getline</span>(fio, line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print line in Console</span></span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the file</span></span><br><span class="line">    fio.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中 <code>getline(fio, line)</code> 函数用于从文件流中读取整行字符串。EOF (End of File) 是在 <code>iostream</code> 类中定义的一个整型常量，值为 -1。</p>
<p>打开文件的常见的模式有：</p>
<ul>
<li><code>std::ios::in</code>：以输入模式打开文件。</li>
<li><code>std::ios::out</code>：以输出模式打开文件。</li>
<li><code>std::ios::app</code>：以追加模式打开文件。</li>
<li><code>std::ios::ate</code>：打开文件并定位到文件末尾。</li>
<li><code>std::ios::trunc</code>：打开文件并截断文件，即清空文件内容。</li>
</ul>
<h1 id="预处理指令"><a class="markdownIt-Anchor" href="#预处理指令"></a> 预处理指令</h1>
<p>预处理器是在实际编译开始之前处理源代码的程序。所有预处理的指令，必须独占一行，并以 <code>#</code> 开始，<strong>末尾不加分号</strong>。</p>
<h2 id="宏定义"><a class="markdownIt-Anchor" href="#宏定义"></a> 宏定义</h2>
<p><code>#define</code> 预处理指令用于创建符号常量，该符号常量通常称为宏。关键字 <code>#define</code> 和 <code>#undef</code> 用于在 C 中创建和删除宏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR printf(<span class="meta-string">&quot;\n&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p>我们还可以将参数传递给宏。这些宏的工作方式类似于函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AREA(r) (PI * (r) * (r))</span></span><br></pre></td></tr></table></figure>
<p>参数加括号是因为宏定义只是简单的替换。</p>
<p>ANSI C 定义了许多宏，它们的名字的前后有两个下划线作为标识，例如：</p>
<ul>
<li><code>__LINE__</code> 代表源代码文件中的当前行</li>
<li><code>__FILE__</code> 代表文件的名字</li>
<li><code>__DATE__</code> 表示编译日期，格式为 <code>mmm dd yyyy</code></li>
<li><code>__TIME__</code> 表示编译时间，格式为 <code>hh:mm:ss</code></li>
</ul>
<h2 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h2>
<p>一个项目往往包含多个源码文件，通常的做法是创建一个 <strong>头文件</strong>，然后使用预处理器指令 <code>#include</code> 加载进入当前文件。头文件用于放置对应源文件里面函数声明等内容，不包括函数定义和实现。</p>
<p>有两种形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myfile.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>尖括号 <code>&lt;&gt;</code> 是用来引入标准库中的头文件，双引号是用来引入用户自定义的头文件。</p>
<p>C++头文件不是以 <code>.h</code> 做扩展名，C 语言中的标准头文件如 <code>math.h, stdio.h</code> 在 C++中被命名为 <code>cmath, cstdio</code>。</p>
<p>例如，我们想在主程序中引入一个函数 <code>add</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(iint x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要创建一个和源文件同名的头文件 <code>add.h</code> ，里边只放入函数声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后就可以在主文件引入使用了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of 3 and 4 is: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译多个文件组成的程序时，需要在命令行中列出它们：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ -o main main.cpp add.cpp</span><br></pre></td></tr></table></figure>
<p>如果编译的文件分别位于不同的目录下，编译时可以通过 <code>-I</code> 选项来指明头文件搜索路径</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ -o main -I/<span class="built_in">source</span>/includes main.cpp</span><br></pre></td></tr></table></figure>
<h2 id="条件编译"><a class="markdownIt-Anchor" href="#条件编译"></a> 条件编译</h2>
<p>头文件里面还可以加载其他头文件，因此有可能产生重复加载，这将产生错误。为了防止这种情况，标准的做法是每个头文件都包含头文件包含。预处理指令包括：<code>#if, #ifdef, #ifndef, else, #elif, #endif</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_FILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_FILE_H</span></span><br><span class="line"><span class="comment">// the entire header file file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这时，当头文件被包含时，预处理器会检查 HEADER_FILE_H 是否已经被定义过。如果该头文件之前已经被包含了，那么预处理器会跳过文件的整个内容。</p>
<p>所有的头文件都应该有头文件保护。但根据惯例，它被设置为头文件的完整文件名，以大写字母键入，使用下划线表示空格或标点。标准库头文件也使用头文件保护。</p>
<p>现代编译器使用更简单的 <code>#pragma</code> 请求编译器保护头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// your code here</span></span><br></pre></td></tr></table></figure>
<p>目前对 <code>#pragma once</code> 的支持是相当普遍的，由于不是由 C++标准定义的，因此一些编译器可能不会实现它。</p>
<h1 id="模块管理"><a class="markdownIt-Anchor" href="#模块管理"></a> 模块管理</h1>
<h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2>
<p>从 C++20 开始，C++ 引入了模块（Modules），并在 C++23 中进一步完善了对标准库模块的支持。模块提供了一种更高效、更安全的方式来导入标准库。模块只编译一次，后续导入时直接使用编译好的二进制接口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, C++23 Modules!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者导入标准库的特定部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> std.core;</span><br><span class="line"><span class="keyword">import</span> std.iostream;</span><br></pre></td></tr></table></figure>
<p>目前，主流编译器对 C++ 模块的支持正在逐步完善。以下是一些编译器启用 C++23 标准和模块支持的方法：</p>
<ul>
<li>GCC：<code>g++ -std=c++23 -fmodules-ts -o program main.cpp</code></li>
<li>Clang：<code>clang++ -std=c++23 -fmodules -o program main.cpp</code></li>
<li>MSVC（Visual Studio）：<code>cl /std:c++23 /experimental:module /EHsc /Fe:program main.cpp</code></li>
</ul>
<h2 id="static"><a class="markdownIt-Anchor" href="#static"></a> static</h2>
<p>正常情况下，当前文件内部的全局变量，可以被其他文件使用。有时候，不希望发生这种情况，而是希望某个变量只局限在当前文件内部使用，不要被其他文件引用。这时可以在声明变量的时候，使用 <code>static</code>关键字，使得该变量变成当前文件的私有变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Variable with internal linkage</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> animals = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="/img/cpp-introduction.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/morty3.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/morty3.jpg" alt="Give me money!"/></a><div class="post-qr-code-desc">Give me money!</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/dc8936d5/" title="Python(Machine Learning)--CatBoost"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/catboost.svg" onerror="onerror=null;src='/img/404_moon.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python(Machine Learning)--CatBoost</div></div></a></div><div class="next-post pull-right"><a href="/posts/e88bb280/" title="C++ 标准库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cpp-introduction.png" onerror="onerror=null;src='/img/404_moon.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ 标准库</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/e88bb280/" title="C++ 标准库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cpp-introduction.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-04</div><div class="title">C++ 标准库</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Tiny Lei</div><div class="author-info__description">每天进步一点点...</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">110</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/wilenwu" rel="external nofollow noreferrer" target="_blank" title="Gitee"><i class="iconfont icon-gitee"></i></a><a class="social-icon" href="https://github.com/wilenwu" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_41518277" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="iconfont icon-csdn"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="iconfont icon-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">感谢访问本站，若喜欢请收藏^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text"> 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text"> 程序结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">1.2.</span> <span class="toc-text"> 编译和运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.</span> <span class="toc-text"> 注释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text"> 数据类型与变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text"> 数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text"> 定义变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AE%8F"><span class="toc-number">2.3.</span> <span class="toc-text"> 常量和宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">2.4.</span> <span class="toc-text"> 命名空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text"> 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text"> 算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text"> 关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.3.</span> <span class="toc-text"> 逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text"> 按位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.</span> <span class="toc-text"> 赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.6.</span> <span class="toc-text"> 三元运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeof"><span class="toc-number">3.7.</span> <span class="toc-text"> sizeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.</span> <span class="toc-text"> 静态转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.</span> <span class="toc-text"> 标准输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cstdio"><span class="toc-number">4.0.1.</span> <span class="toc-text"> cstdio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iostream"><span class="toc-number">4.0.2.</span> <span class="toc-text"> iostream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text"> 流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.</span> <span class="toc-text"> 条件语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-else"><span class="toc-number">5.1.1.</span> <span class="toc-text"> if-else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-case"><span class="toc-number">5.1.2.</span> <span class="toc-text"> switch-case</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.2.</span> <span class="toc-text"> 循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#while"><span class="toc-number">5.2.1.</span> <span class="toc-text"> while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while"><span class="toc-number">5.2.2.</span> <span class="toc-text"> do-while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">5.2.3.</span> <span class="toc-text"> for</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.3.</span> <span class="toc-text"> 跳转语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#break"><span class="toc-number">5.3.1.</span> <span class="toc-text"> break</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#continue"><span class="toc-number">5.3.2.</span> <span class="toc-text"> continue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text"> 指针和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">6.1.</span> <span class="toc-text"> 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">6.2.</span> <span class="toc-text"> 指针运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">6.3.</span> <span class="toc-text"> 指针的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">6.4.</span> <span class="toc-text"> 空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">6.5.</span> <span class="toc-text"> 引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text"> 派生数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">7.1.</span> <span class="toc-text"> 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.1.1.</span> <span class="toc-text"> 声明和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">7.1.2.</span> <span class="toc-text"> 数组与指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.1.3.</span> <span class="toc-text"> 多维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">7.2.</span> <span class="toc-text"> 字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">7.3.</span> <span class="toc-text"> 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">7.3.1.</span> <span class="toc-text"> 定义和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%B5%8C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">7.3.2.</span> <span class="toc-text"> 内嵌结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">7.3.3.</span> <span class="toc-text"> 结构体指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-number">7.3.4.</span> <span class="toc-text"> 结构体数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.4.</span> <span class="toc-text"> 枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">7.5.</span> <span class="toc-text"> 类型别名</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text"> 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text"> 定义和调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E"><span class="toc-number">8.2.</span> <span class="toc-text"> 前向声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">8.3.</span> <span class="toc-text"> 参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">8.4.</span> <span class="toc-text"> 默认参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">8.5.</span> <span class="toc-text"> 命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">8.6.</span> <span class="toc-text"> 返回指针的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">8.7.</span> <span class="toc-text"> 递归函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">8.8.</span> <span class="toc-text"> 函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">8.9.</span> <span class="toc-text"> 函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">8.10.</span> <span class="toc-text"> 模板函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">8.11.</span> <span class="toc-text"> lambda 表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text"> 动态内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.</span> <span class="toc-text"> 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.1.</span> <span class="toc-text"> 类与对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">10.2.</span> <span class="toc-text"> 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.</span> <span class="toc-text"> 构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">10.4.</span> <span class="toc-text"> 析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-%E6%8C%87%E9%92%88"><span class="toc-number">10.5.</span> <span class="toc-text"> this 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.</span> <span class="toc-text"> 友元函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">10.7.</span> <span class="toc-text"> 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96"><span class="toc-number">10.8.</span> <span class="toc-text"> 函数覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">10.9.</span> <span class="toc-text"> 运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">10.10.</span> <span class="toc-text"> 虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">10.11.</span> <span class="toc-text"> 类模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">10.12.</span> <span class="toc-text"> 类与头文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text"> 异常处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81"><span class="toc-number">12.</span> <span class="toc-text"> 文件和流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cstdio-2"><span class="toc-number">12.1.</span> <span class="toc-text"> cstdio</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fstream"><span class="toc-number">12.2.</span> <span class="toc-text"> fstream</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">13.</span> <span class="toc-text"> 预处理指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">13.1.</span> <span class="toc-text"> 宏定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">13.2.</span> <span class="toc-text"> 头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">13.3.</span> <span class="toc-text"> 条件编译</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text"> 模块管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">14.1.</span> <span class="toc-text"> 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">14.2.</span> <span class="toc-text"> static</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/97cab0/" title="深度学习(III)--循环神经网络(RNN)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/DL-RNN.png" onerror="this.onerror=null;this.src='/img/404_moon.png'" alt="深度学习(III)--循环神经网络(RNN)"/></a><div class="content"><a class="title" href="/posts/97cab0/" title="深度学习(III)--循环神经网络(RNN)">深度学习(III)--循环神经网络(RNN)</a><time datetime="2025-09-02T12:00:05.000Z" title="发表于 2025-09-02 20:00:05">2025-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c1ead285/" title="深度学习(II)--卷积神经网络(CNN)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/DL-CNN.png" onerror="this.onerror=null;this.src='/img/404_moon.png'" alt="深度学习(II)--卷积神经网络(CNN)"/></a><div class="content"><a class="title" href="/posts/c1ead285/" title="深度学习(II)--卷积神经网络(CNN)">深度学习(II)--卷积神经网络(CNN)</a><time datetime="2025-08-25T15:32:00.000Z" title="发表于 2025-08-25 23:32:00">2025-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c64a04c1/" title="深度学习(I)--前馈神经网络(FNN)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/DL-FNN.png" onerror="this.onerror=null;this.src='/img/404_moon.png'" alt="深度学习(I)--前馈神经网络(FNN)"/></a><div class="content"><a class="title" href="/posts/c64a04c1/" title="深度学习(I)--前馈神经网络(FNN)">深度学习(I)--前馈神经网络(FNN)</a><time datetime="2025-08-19T14:06:00.000Z" title="发表于 2025-08-19 22:06:00">2025-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/619a34fc/" title="Python(Scientific Computing)--Cython"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cython-cover.jpg" onerror="this.onerror=null;this.src='/img/404_moon.png'" alt="Python(Scientific Computing)--Cython"/></a><div class="content"><a class="title" href="/posts/619a34fc/" title="Python(Scientific Computing)--Cython">Python(Scientific Computing)--Cython</a><time datetime="2025-03-26T08:05:01.000Z" title="发表于 2025-03-26 16:05:01">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e88bb280/" title="C++ 标准库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cpp-introduction.png" onerror="this.onerror=null;this.src='/img/404_moon.png'" alt="C++ 标准库"/></a><div class="content"><a class="title" href="/posts/e88bb280/" title="C++ 标准库">C++ 标准库</a><time datetime="2025-03-04T04:04:01.000Z" title="发表于 2025-03-04 12:04:01">2025-03-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Tiny Lei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'forest'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function getGiscusTheme (theme) {
  return theme === 'dark' ? 'dark' : 'light'
}

function loadGiscus () {
  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'WilenWu/giscus-comments',
    'data-repo-id': 'R_kgDONXyMwg',
    'data-category-id': 'DIC_kwDONXyMws4Ckzx5',
    'data-mapping': 'pathname',
    'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme (theme) {
  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame')
    if (!iframe) return
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
  }

  sendMessage({
    setConfig: {
      theme: getGiscusTheme(theme)
    }
  });
}

btf.addModeChange('giscus', changeGiscusTheme)

if ('Giscus' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script src="/js/custom.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>